<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>Text mining</title>
    <meta charset="utf-8" />
    <meta name="author" content="© Łukasz Wawrowski" />
    <link rel="stylesheet" href="default.css" type="text/css" />
    <link rel="stylesheet" href="default-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Text mining
## na przykładzie Google News
### © Łukasz Wawrowski

---




# Plan szkolenia

1. Wprowadzenie

2. Odlegość pomiędzy tekstami

3. Metoda n-gramów

4. Lematyzacja

---

# Łukasz Wawrowski


---

# Why R?

1. Natywna obsługa danych

2. Łatwe w obsłudze repozytorium pakietów

3. [Programowanie funkcyjne](https://adv-r.hadley.nz/fp.html)

4. [Metaprogramowanie](https://adv-r.hadley.nz/metaprogramming.html)

???

https://blog.shotwell.ca/posts/why_i_use_r/


---

# Źródła danych

---

# Wprowadzenie

Text mining - ogólna nazwa metod eksploracji danych służących do wydobywania danych z tekstu i ich późniejszej obróbki [[Wikipedia](https://pl.wikipedia.org/wiki/Text_mining)].

Zastosowania:

- łączenie niedeterministyczne

- analiza wydzwięku/sentymentu

- przetwarzanie języka naturalnego

---

# Tekst - nośnik wiedzy

- dane wejściowe (imona, nazwiska, kategorie)

- dane wyjściowe (skrypty, PDF, strony internetowe)

---

# Przetwarzanie tekstu w R

Operacje na wektorach.

--


```r
tekst &lt;- "Text mining w R"

nchar(tekst)
```

```
## [1] 15
```

```r
charToRaw(tekst)
```

```
##  [1] 54 65 78 74 20 6d 69 6e 69 6e 67 20 77 20 52
```

```r
rawToChar(rev(charToRaw(tekst)))
```

```
## [1] "R w gninim txeT"
```

--

Bazowe funkcje w R są mało intuicyjne.

---

# Przetwarzanie napisów

Pakiet **stringi** autorstwa Marka Gągolewskiego zawierający 234 funkcje.

Pakiet **stringr** zawierający 42 funkcje z pakietu **stringi**.

- prosty w użyciu - funkcje zaczynają się przedrostkiem `stri_`

- wiele przydatnych funkcji

- bardzo szybki

- bardzo _eRowy_


```r
paste(letters[1:3], NA)
```

```
## [1] "a NA" "b NA" "c NA"
```

```r
stri_join(letters[1:3], NA)
```

```
## [1] NA NA NA
```

???

https://drive.google.com/drive/u/0/folders/0B-ZJyVlQBsqlcXRsaHI5bDdtaUk

---

# Odległość tekstów

Miara podobieństwa pomiędzy dwoma tekstami. Własności:

1. nieujemność `\(d(s,t) \geq 0\)`

2. identyczność `\(d(s,t) = 0 \Longleftrightarrow s = t\)`

3. symetria `\(d(s,t)=d(t,s)\)`

4. nierówność trójkąta `\(d(s,u) \leq d(s,t) + d(t,u)\)`

---

# Pakiet stringdist

[stringdist](https://cran.r-project.org/web/packages/stringdist/index.html) - Approximate String Matching and String Distance Functions.

[van der Loo M (2014). “The stringdist package for approximate string matching.” _The R Journal_, *6*, 111-122.](https://journal.r-project.org/archive/2014-1/loo.pdf)

Funkcje


```r
stringdist(a = "tekst1", b = "tekst2", method = "osa", q = 1, p = 0)
```

```
## [1] 1
```


```r
stringdistmatrix(a = c("tekst1", "tekst2"), 
                 b = "tekst2", 
                 method = "osa", 
                 q = 1, 
                 p = 0)
```

```
##      [,1]
## [1,]    1
## [2,]    0
```

---

# Odległość Hamminga

Liczba różnych znaków na tej samej pozycji w obu ciągach. Może być obliczona tylko dla tekstów o tej samej długości.


```r
stringdist("wydawnictwo", "wydawnicwto", method = "hamming")
```

```
## [1] 2
```


```r
stringdist("przynajmniej", "bynajmniej", method = "hamming")
```

```
## [1] Inf
```

---

# Najdłuższy wspólny podłańcuch 

Znajduje najdłuższy ciąg znaków (ang. longest common substring) leżących obok siebie w obu ciągach, natomiast odległość to liczba niesparowanych znaków.


```r
stringdist("wydawnictwo", "wydawnicwto", method = "lcs")
```

```
## [1] 2
```


```r
stringdist("przynajmniej", "bynajmniej", method = "lcs")
```

```
## [1] 4
```

---

# Odległość Levenshteina

Odległość to liczba kroków wymaganych do przekształcenia jednego ciągu znaków w drugi. Działania jakie można wykonywać to wstawienie nowego znaku, usunięcie znaku lub zamianę znaku na nowy znak.


```r
stringdist("wydawnictwo", "wydawnicwto", method = "lv")
```

```
## [1] 2
```


```r
stringdist("przynajmniej", "bynajmniej", method = "lv")
```

```
## [1] 3
```

---

# Odległość Damerau-Levenshteina 

Podobnie jak odległość Levenshteina, ale wprowadza działanie polegające na zamianie miejscami sąsiadujących znaków.


```r
stringdist("wydawnictwo", "wydawnicwto", method = "dl")
```

```
## [1] 1
```


```r
stringdist("przynajmniej", "bynajmniej", method = "dl")
```

```
## [1] 3
```

---

### Odległość Damerau-Levenshteina z ograniczeniem 

_Optimal string aligment_ - podobnie jak odległość Damerau-Levenshteina, ale każdy podłańcuch może być modyfikowany tylko raz. Nie spełnia nierówności trójkąta.


```r
stringdist("wydawnictwo", "wydawnicwto", method = "osa")
```

```
## [1] 1
```


```r
stringdist("przynajmniej", "bynajmniej", method = "osa")
```

```
## [1] 3
```

---

# Q-gram

Ciąg zawierający `\(q\)` następujących po sobie znaków ( `\(v(s;q)\)` ). Odległość można zdefiniować jako liczbę unikalnych `\(q\)` gramów.


```r
qgrams("przynajmniej", "bynajmniej", q=2)
```

```
##    pr rz zy yn na ni aj jm mn ie ej by
## V1  1  1  1  1  1  1  1  1  1  1  1  0
## V2  0  0  0  1  1  1  1  1  1  1  1  1
```


```r
stringdist("przynajmniej", "bynajmniej", method = "qgram", q = 2)
```

```
## [1] 4
```

---

# Q-gram


```r
qgrams("wydawnictwo", "wydawnicwto", q=2)
```

```
##    wy yd da wn wo wt ni tw to ic aw ct cw
## V1  1  1  1  1  1  0  1  1  0  1  1  1  0
## V2  1  1  1  1  0  1  1  0  1  1  1  0  1
```


```r
stringdist("wydawnictwo", "wydawnicwto", method = "qgram", q = 2)
```

```
## [1] 6
```

---

# Odległość Jaccarda

Jeśli `\(Q(s;q)\)` oznacza zbiór unikalnych `\(q\)` gramów w ciągu `\(s\)` to odległość Jaccarda jest zdefiniowana jako:

`$$d(s,t;q)=1-\frac{|Q(s;q) \cap Q(t;q)|}{|Q(s;q) \cup Q(t;q)|}$$`

gdzie pionowe kreski oznaczają liczbę unikalnych elementów w zbiorze. Odległość Jaccarda zawiera się w przedziale od 0 do 1, gdzie 0 oznacza teksty identyczne ( `\(Q(s;q) = Q(t;q)\)` ), a 1 zupełnie różne ( `\(Q(s;q) \cap Q(t;q)=\emptyset\)` )


```r
stringdist("przynajmniej", "bynajmniej", method = "jaccard", q = 2)
```

```
## [1] 0.3333333
```



```r
stringdist("wydawnictwo", "wydawnicwto", method = "jaccard", q = 2)
```

```
## [1] 0.4615385
```

---

# Odległość cosinusowa

Odległość cosinusowa jest zdefiniowana jako:

`$$d(s,t;q)=1-\frac{v(s;q)\cdot v(t;q)}{||v(s;q)||_2||v(t;q)||_2}$$`

Odległość cosinusowa wynosi 0 jeśli oba ciągi są takie same oraz 1, gdy nie ma żadnych wspólnych `\(q\)` gramów.


```r
stringdist("przynajmniej", "bynajmniej", method = "cosine", q = 2)
```

```
## [1] 0.1959697
```



```r
stringdist("wydawnictwo", "wydawnicwto", method = "cosine", q = 2)
```

```
## [1] 0.3
```

---

# Odległość Jaro

Średnia z odsetka wspólnych znaków w pierwszym ciągu, odsetka wspólnych znaków w drugim ciągu oraz odsetka wspólnych znaków nie wymagających transpozycji. Przyjmuje wartości od 0 do 1, gdzie 0 to teksty identyczne, a 1 zupełnie różne.


```r
stringdist("wydawnictwo", "wydawnicwto", method = "jw")
```

```
## [1] 0.03030303
```


```r
stringdist("przynajmniej", "bynajmniej", method = "jw")
```

```
## [1] 0.1166667
```

---

# Odległość Jaro-Winklera 

Zwiększenie podobieństwa ciągów, które według odległości Jaro są do siebie podobne. Kara za wykonanie modyfikacji z przedziału `\(0-0.25\)`.


```r
stringdist("wydawnictwo", "wydawnicwto", method = "jw", p = 0.1)
```

```
## [1] 0.01818182
```


```r
stringdist("przynajmniej", "bynajmniej", method = "jw", p = 0.1)
```

```
## [1] 0.1166667
```

???

[źródło](https://www.joyofdata.de/blog/comparison-of-string-distance-algorithms/)

---

# Soundex

Ciąg znaków jest tłumaczony do zapisu fonetycznego. Jeżeli zapis fonetyczny jest taki sam to odległość wynosi 0, a w przeciwnym przypadku 1. Działa wyłącznie dla liter a-z.


```r
phonetic("beer")
```

```
## [1] "B600"
```



```r
stringdist("beer", "wine", method = "soundex")
```

```
## [1] 1
```



```r
stringdist("bear", "beer", method = "soundex")
```

```
## [1] 0
```

---

# Podsumowanie

Im mniej tym większe podobieństwo

- najdłuższy wspólny podłańcuch (`lcs`)

- odległość Levenshteina (`lv`)

- odległość Damerau-Levenshteina (`dl`)

- odległość Damerau-Levenshteina z ograniczeniem (`osa`)

- q-gram (`qgram`)

Z przedziału 0-1 - 0 oznacza identyczne ciągi

- odległość Jaccarda (`jaccard`)

- odległość cosinusowa (`cosine`)

- odległość Jaro i Jaro-Winklera (`jw`)

- soundex

---

# Przykład

Podczas kolokwium studenci udostępniali swoje kody R, które wykorzystali do rozwiązania zadań. Za pomocą analizy podobieństwa sprawdź czy można na tej podstawie zidentyfikować studentów, którzy nie pracowali samodzielnie.

Zbiór danych [kody](data/kody.RData):

- id - identyfikator osoby i grupy

- odp - kod R 

---

# Zadanie

Nazwiska lubią być przekręcane. Na podstawie [bazy nazwisk w województwie śląskim](data/nazwiska.RData) zidentyfikuj te najbardziej podobne z wykorzystaniem różnych miar odległości. Ze względu na bardzo dużą liczbę obserwacji warto ograniczyć się do nazwisk występujących np. conajmniej 200 razy. 

Jak można przekręcić nazwisko "Kowalski"? Jakie nazwiska mogą powstać poprzez zmianę tylko jednej litery w tym nazwisku?

---

# Części mowy

- rzeczownik (NOUN)
- czasownik (VERB)
- przymiotnik (ADJ - adjective)
- przysłówek (ADV - adverb)

- zaimek (PRON - pronoun)
- nazwy własne (PROPN - proper noun)
- przyimki określajace położenie (ADP - adposition)
- wykrzyknik (INTJ - interjection)
- spójnik koordynujący (CCONJ - coordinating conjunction)
- znak interpunkcyjny (PUNCT - punctuation)
- liczebnik (NUM - numeral)
- partykuła (PART = particle)
- (AUX - auxiliary)
- (DET - determiner)
- spójnik podrzędny (SCONJ - subordinating conjunction)
- (SYM - symbol)

[źródło](https://universaldependencies.org/u/pos/index.html)

---

# Lematyzacja

Sprowadzanie formy fleksyjnej wyrazu do postaci słownikowej.

---

# Zbiór wynikowy

---

# Kontekst

Dla słów ważny jest kontekst. 

- RAKE (Rapid Automatic Keyword Extraction)

- Punktowa wzajemna informacja (Pointwise mutual information)

- Parts of Speech phrase sequence detection

---

# RAKE

https://monkeylearn.com/keyword-extraction/

---

# PMI

https://en.wikipedia.org/wiki/Pointwise_mutual_information
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
